#!/bin/sh
#-*- sh -*-

# some constants #
AR=ar
CC=clang
CXX=clang++
LD=ld
OBJCOPY=objcopy
OUTPUT_NAME=bin/printf2
OUTPUT_LIBRARY=bin/libprintf2.a
LIBRARIES="-lc bin/libenet.a"
# FLAGS="-fsanitize=address -g"
FLAGS="-O3"
INCLUDES="-Ilib/enet/include -Isrc -Ilib -Iinc"
##################

# internal vars dont touch #
ARGS=( $@ )
NARG=0
PROG_NAME=$0
############################

set -e

# $1 offset
getarg() {
  echo ${ARGS[$NARG + $1]}
}

argv() {
  R=${ARGS[@]:$NARG}
  echo ${R[@]}
}

target_build_depend() {
  make all
}

target_build() {
  mkdir -p bin
  target_build_depend
  $CXX src/ServerMain.cpp bin/libserver.a -lGL -lXcursor -lXi -lX11 $FLAGS $LIBRARIES $INCLUDES -o bin/printf2_server
  $CC src/ClientMain.c -lpthread $FLAGS $LIBRARIES $INCLUDES -o bin/printf2_client
  $CC src/ClientLibrary.c $FLAGS $INCLUDES -c
  $LD -r *.o bin/libenet.a -o Out.o
  $OBJCOPY --keep-global-symbols=GlobalSymbols.txt Out.o Out.o
  $AR rcs bin/libprintf2.a Out.o
  rm Out.o
}

target_run() {
  target_build
  bin/printf2_$1 `argv`
}

target_test() {
  $CC $INCLUDES -Iinc test/$1.c -fsanitize=address -Isrc -g && ./a.out
  rm a.out
}

hasargs=1

# Fetch all sparse args
while [ $hasargs -eq 1 ]
do
  case `getarg 0` in
    *)
      hasargs=0
    ;;
  esac
done

case `getarg 0` in
  test)
    target_test `getarg 1`
  ;;
  build)
    target_build
  ;;
  run)
    target_run `getarg 1`
  ;;
  *)
    echo "You can do: run, build"
  ;;
esac


